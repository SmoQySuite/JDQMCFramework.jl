var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Propagator-Types","page":"API","title":"Propagator Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractPropagator\nAbstractExactPropagator\nAbstractChkbrdPropagator\nSymExactPropagator\nAsymExactPropagator\nSymChkbrdPropagator\nAsymChkbrdPropagator\nSymPropagators","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractPropagator\nAbstractExactPropagator\nAbstractChkbrdPropagator\nSymExactPropagator\nAsymExactPropagator\nSymChkbrdPropagator\nAsymChkbrdPropagator\nSymPropagators","category":"page"},{"location":"api/#JDQMCFramework.AbstractPropagator","page":"API","title":"JDQMCFramework.AbstractPropagator","text":"abstract type AbstractPropagator{T<:Continuous, E<:AbstractFloat} end\n\nAbstract type to represent imaginary time propagator matrices B. All specific propagators types inherit from this abstract type. In the above T is data type of the matrix elements in a propagator matrix B_l and E is the type of Deltatau.\n\n\n\n\n\n","category":"type"},{"location":"api/#JDQMCFramework.AbstractExactPropagator","page":"API","title":"JDQMCFramework.AbstractExactPropagator","text":"abstract type AbstractExactPropagator{T,E} <: AbstractPropagator{T,E} end\n\nAbstract type to represent imaginary time propagator matrices B defined with an exactly exponentiated hopping matrix K.\n\n\n\n\n\n","category":"type"},{"location":"api/#JDQMCFramework.AbstractChkbrdPropagator","page":"API","title":"JDQMCFramework.AbstractChkbrdPropagator","text":"abstract type AbstractChkbrdPropagator{T,E} <: AbstractPropagator{T,E} end\n\nAbstract type to represent imaginary time propagator matrices B defined with the exponentiated hopping matrix K represented by the checkerboard approximation.\n\n\n\n\n\n","category":"type"},{"location":"api/#JDQMCFramework.SymExactPropagator","page":"API","title":"JDQMCFramework.SymExactPropagator","text":"SymExactPropagator{T, E} <: AbstractExactPropagator{T,E}\n\nRepresents imaginary time propagator matrix as using the symmetric form\n\nB_l = e^-Deltatau K_l2 e^-Deltatau V_l e^-Deltatau K_l2\n\nwhere K_l is the strictly off-diagonal hopping matrix and V_l is the diagonal total on-site energy matrix.\n\nFields\n\nexpmΔτV::Vector{E}: A vector representing the diagonal exponeniated on-site energy matrix e^-Deltatau V_l\nexpmΔτKo2::Matrix{T}: The exponentiated hopping matrix e^-Deltatau K_l2\nexppΔτKo2::Matrix{T}: Inverse of the exponentiated hopping matrix e^+Deltatau K_l2\n\n\n\n\n\n","category":"type"},{"location":"api/#JDQMCFramework.AsymExactPropagator","page":"API","title":"JDQMCFramework.AsymExactPropagator","text":"AsymExactPropagator{T, E} <: AbstractExactPropagator{T,E}\n\nRepresents imaginary time propagator matrix as using the symmetric form\n\nB_l = e^-Deltatau V_l e^-Deltatau K_l\n\nwhere K_l is the strictly off-diagonal hopping matrix and V_l is the diagonal total on-site energy matrix.\n\nFields\n\nexpmΔτV::Vector{E}: A vector representing the diagonal exponeniated on-site energy matrix e^-Deltatau V_l\nexpmΔτK::Matrix{T}: The exponentiated hopping matrix e^-Deltatau K_l\nexppΔτK::Matrix{T}: Inverse of the exponentiated hopping matrix e^+Deltatau K_l\n\n\n\n\n\n","category":"type"},{"location":"api/#JDQMCFramework.SymChkbrdPropagator","page":"API","title":"JDQMCFramework.SymChkbrdPropagator","text":"SymChkbrdPropagator{T, E} <: AbstractChkbrdPropagator{T,E}\n\nRepresents imaginary time propagator matrix as using the symmetric form\n\nB_l = e^-Deltatau K_l2 e^-Deltatau V_l e^-Deltatau K_l2^dagger\n\nwhere K_l is the strictly off-diagonal hopping matrix and V_l is the diagonal total on-site energy matrix. The exponentiated hopping matrix e^-Deltatau K2 is represented by the checkerboard approximation.\n\nFields\n\nexpmΔτV::Vector{E}: A vector representing the diagonal exponeniated on-site energy matrix e^-Deltatau V_l\nexpmΔτKo2::CheckerboardMatrix{T}: The exponentiated hopping matrix e^-Deltatau K_l2 represented by the checkerboard approximation.\n\n\n\n\n\n","category":"type"},{"location":"api/#JDQMCFramework.AsymChkbrdPropagator","page":"API","title":"JDQMCFramework.AsymChkbrdPropagator","text":"AsymChkbrdPropagator{T, E} <: AbstractChkbrdPropagator{T,E}\n\nRepresents imaginary time propagator matrix as using the symmetric form\n\nB_l = e^-Deltatau V_l e^-Deltatau K_l\n\nwhere K_l is the strictly off-diagonal hopping matrix and V_l is the diagonal total on-site energy matrix. The exponentiated hopping matrix e^-Deltatau K is represented by the checkerboard approximation.\n\nFields\n\nexpmΔτV::Vector{E}: The vector representing the diagonal exponeniated on-site energy matrix e^-Deltatau V_l\nexpmΔτK::CheckerboardMatrix{T}: The exponentiated hopping matrix e^-Deltatau K_l represented by the checkerboard approximation.\n\n\n\n\n\n","category":"type"},{"location":"api/#JDQMCFramework.SymPropagators","page":"API","title":"JDQMCFramework.SymPropagators","text":"SymPropagators\n\nA union of the all the symmetric propagators types to help test whether a propagator type is symmetric. Assuming typeof{B} <: AbstractPropagator returns true, if typeof(B) <: SymPropagators returns true, then B represents a symmetric propagator, otherwise it represents an asymmetric propagator.\n\n\n\n\n\n","category":"type"},{"location":"api/#Propagator-Functions","page":"API","title":"Propagator Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"size\ncopyto!\nmul!\nlmul!\nrmul!\nldiv!\nrdiv!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Base.size\nBase.copyto!\nLinearAlgebra.mul!\nLinearAlgebra.lmul!\nLinearAlgebra.rmul!\nLinearAlgebra.ldiv!\nLinearAlgebra.rdiv!","category":"page"},{"location":"api/#Base.size","page":"API","title":"Base.size","text":"size(B::AbstractPropagator)\nsize(B::AbstractPropagator, dim)\n\nReturn the size of a propagator.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.copyto!","page":"API","title":"Base.copyto!","text":"copyto!(B′::SymExactPropagator{T,E}, B::SymExactPropagator{T,E}) where {T,E}\n\ncopyto!(B′::AsymExactPropagator{T,E}, B::AsymExactPropagator{T,E}) where {T,E}\n\ncopyto!(B′::SymChkbrdPropagator{T,E}, B::SymChkbrdPropagator{T,E}) where {T,E}\n\ncopyto!(B′::AsymChkbrdPropagator{T,E}, B::AsymChkbrdPropagator{T,E}) where {T,E}\n\nCopy the propagator B to B′.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.mul!","page":"API","title":"LinearAlgebra.mul!","text":"mul!(A::AbstractMatrix{T}, B::SymExactPropagator{T}, C::AbstractMatrix{T};\n     M::AbstractMatrix{T}=similar(A)) where {T}\n\nmul!(A::AbstractMatrix{T}, B::AsymExactPropagator{T}, C::AbstractMatrix{T};\n     M::AbstractMatrix{T}=similar(A)) where {T}\n\nmul!(A::AbstractMatrix{T}, B::AbstractChkbrdPropagator{T}, C::AbstractMatrix{T};\n     M=nothing) where {T}\n\nCalculate the product A = B cdot C, where B is a propagator matrix represented by an instance of a type inheriting from AbstractPropagator. If B is asymmetric and B.adjointed = true, then A = B^dagger cdot C is evaluated instead.\n\n\n\n\n\nmul!(A::AbstractMatrix{T}, C::AbstractMatrix{T}, B::SymExactPropagator{T};\n     M::AbstractMatrix{T} = similar(A)) where {T}\n\nmul!(A::AbstractMatrix{T}, C::AbstractMatrix{T}, B::AsymExactPropagator{T};\n     M::AbstractMatrix{T} = similar(A)) where {T}\n\nmul!(A::AbstractMatrix{T}, C::AbstractMatrix{T}, B::AbstractChkbrdPropagator{T};\n     M=nothing) where {T}\n\nCalculate the matrix product A = C cdot B, where B is a propagator matrix represented by an instance of a type inheriting from AbstractPropagator. If B is asymmetric and B.adjointed = true, then A = C cdot B^dagger is evaluated instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.lmul!","page":"API","title":"LinearAlgebra.lmul!","text":"lmul!(B::SymExactPropagator{T}, A::AbstractMatrix{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nlmul!(B::AsymExactPropagator{T}, A::AbstractMatrix{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nlmul!(B::AsymExactPropagator{T}, A::AbstractMatrix{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nlmul!(B::AsymChkbrdPropagator{T}, A::AbstractMatrix{T};\n      M = nothing) where {T}\n\nCalculate the matrix product A = B cdot A, where B is a propagator matrix represented by an instance of a type inheriting from AbstractPropagator. If B is asymmetric and B.adjointed = true, when A = B^dagger cdot A is evaluated instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.rmul!","page":"API","title":"LinearAlgebra.rmul!","text":"rmul!(A::AbstractMatrix{T}, B::SymExactPropagator{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nrmul!(A::AbstractMatrix{T}, B::AsymExactPropagator{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nrmul!(A::AbstractMatrix{T}, B::SymChkbrdPropagator{T};\n      M = nothing) where {T}\n\nrmul!(A::AbstractMatrix{T}, B::AsymChkbrdPropagator{T};\n      M = nothing) where {T}\n\nCalculate the matrix product A = A cdot B, where B is a propagator matrix represented by an instance of a type inheriting from AbstractPropagator. If B is asymmetric and B.adjointed = true, then A = A cdot B^dagger is evaluated instead. \n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.ldiv!","page":"API","title":"LinearAlgebra.ldiv!","text":"ldiv!(A::AbstractMatrix{T}, B::AbstractExactPropagator{T}, C::AbstractMatrix{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nldiv!(A::AbstractMatrix{T}, B::AbstractChkbrdPropagator{T}, C::AbstractMatrix{T};\n      M = nothing) where {T}\n\nCalculate the matrix product A = B^-1 cdot C, where B is a propagator matrix represented by an instance of a type inheriting from AbstractPropagator. If B is asymmetric and B.adjointed = true, then A = B^dagger^-1 cdot C is evaluated instead.\n\n\n\n\n\nldiv!(B::SymExactPropagator{T}, A::AbstractMatrix{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nldiv!(B::AsymExactPropagator{T}, A::AbstractMatrix{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nldiv!(B::SymChkbrdPropagator{T}, A::AbstractMatrix{T};\n      M = nothing) where {T}\n\nldiv!(B::AsymChkbrdPropagator{T}, A::AbstractMatrix{T};\n      M = nothing) where {T}\n\nCalculate the matrix product A = B^-1 cdot A, where B is a propagator matrix represented by an instance of a type inheriting from AbstractPropagator. If B is asymmetric and B.adjointed = true, then A = B^dagger^-1 cdot A is evaluated instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.rdiv!","page":"API","title":"LinearAlgebra.rdiv!","text":"rldiv!(A::AbstractMatrix{T}, C::AbstractMatrix{T}, B::AbstractExactPropagator{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nrdiv!(A::AbstractMatrix{T}, C::AbstractMatrix{T}, B::AbstractChkbrdPropagator{T};\n      M = nothing) where {T}\n\nCalculate the matrix product A = C cdot B^-1, where B is a propagator matrix represented by an instance of a type inheriting from AbstractPropagator. If B is asymmetric and B is asymmetric and B.adjointed = true, then A = C cdot B^dagger^-1 is evaluated instead.\n\n\n\n\n\nrdiv!(A::AbstractMatrix{T}, B::SymExactPropagator{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nrdiv!(A::AbstractMatrix{T}, B::AsymExactPropagator{T};\n      M::AbstractMatrix{T} = similar(A)) where {T}\n\nrdiv!(A::AbstractMatrix{T}, B::SymChkbrdPropagator{T};\n      M = nothing) where {T}\n\nrdiv!(A::AbstractMatrix{T}, B::AsymChkbrdPropagator{T};\n      M = nothing) where {T}\n\nCalculate the matrix product A = A cdot B^-1, where B is a propagator matrix represented by an instance of a type inheriting from AbstractPropagator. If B is asymmetric and B.adjointed = true, then A = A cdot B^dagger^-1 is evaluated instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#FermionGreensCalculator-Type","page":"API","title":"FermionGreensCalculator Type","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FermionGreensCalculator\nfermion_greens_calculator","category":"page"},{"location":"api/","page":"API","title":"API","text":"FermionGreensCalculator\nfermion_greens_calculator","category":"page"},{"location":"api/#JDQMCFramework.FermionGreensCalculator","page":"API","title":"JDQMCFramework.FermionGreensCalculator","text":"FermionGreensCalculator{T<:Continuous, E<:AbstractFloat}\n\nA type to facilitate calculating the single-particle fermion Green's function matrix.\n\nFields\n\nforward::Bool: If true then iterate over imaginary time slices from l=1 to l=L_tau, if false then iterate over imaginary time slices from l=L_tau to l=1.\nl::Int: The current imaginary time slice tau = l cdot Deltatau.\nN::Int: Orbitals in system.\nβ::E: The inverse temperature beta=1T where T is temperature.\nΔτ::E: Discretization in imaginary time.\nLτ::Int: Length of imaginary time axis, L_tau = beta  Deltatau\nnₛ::Int: Frequency with which numerical stabilization is performed, i.e. every n_s imaginary time slices the equal-time Green's function is recomputed from scratch.\nNₛ::Int: Number of numerical stabilization intervals, N_s = leftlceil L_tau  n_s rightrceil\nB̄::Array{T,3}: A multidimensional array where the matrix B̄[:,:,n] represents barB_n\nF::Vector{LDR{T,E}}: A vector of N_s LDR factorizations to represent the matrices B(0tau) and B(taubeta).\nG′::Matrix{T}: Matrix used for calculating the error corrected by numerical stabilization of the equal time Green's function.\nldr_ws::LDRWorkspace{T}: Workspace for performing LDR factorization while avoiding dynamic memory allocations.\n\n\n\n\n\n","category":"type"},{"location":"api/#JDQMCFramework.fermion_greens_calculator","page":"API","title":"JDQMCFramework.fermion_greens_calculator","text":"fermion_greens_calculator(B::AbstractVector{P}, N::Int, β::E, Δτ::E,\n                          nₛ::Int) where {T<:Continuous, E<:AbstractFloat, P<:AbstractPropagator{T}}\n\nInitialize and return FermionGreensCalculator struct based on the vector of propagators B passed to the function.\n\n\n\n\n\n","category":"function"},{"location":"api/#DQMC-Building-Block-Routines","page":"API","title":"DQMC Building Block Routines","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"iterate\ncalculate_equaltime_greens!\npropagate_equaltime_greens!\nstabilize_equaltime_greens!\ncalculate_unequaltime_greens!\nlocal_update_det_ratio\nlocal_update_greens!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Base.iterate\ncalculate_equaltime_greens!\npropagate_equaltime_greens!\nstabilize_equaltime_greens!\ncalculate_unequaltime_greens!\nlocal_update_det_ratio\nlocal_update_greens!","category":"page"},{"location":"api/#Base.iterate","page":"API","title":"Base.iterate","text":"iterate(iter::FermionGreensCalculator)\n\niterate(iter::FermionGreensCalculator, state)\n\nIterate over imaginary time slices, alternating between iterating in the forward direction from l=1 to l=L_tau and in the reverse direction from l=L_tau to l=1. The iter.forward boolean field in the FermionGreensCalculator type determines whether the imaginary time slices are iterated over in forward or reverse order. The iter.forward field is updated as needed automatically and should not be adjusted manually.\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.calculate_equaltime_greens!","page":"API","title":"JDQMCFramework.calculate_equaltime_greens!","text":"calculate_equaltime_greens!(G::AbstractMatrix{T}, fgc::FermionGreensCalculator{T})::Tuple{T,E} where {T}\n\nCalculate the equal-time Greens function G(00) = G(betabeta) = I + B(beta0)^-1 using a numerically stable procedure. This method also returns log(vert det G vert) and textrmsign(det G) Note that this routine requires fgc.l == 1 or fgc.l == fgc.Lτ.\n\n\n\n\n\ncalculate_equaltime_greens!(G::AbstractMatrix{T}, fgc::FermionGreensCalculator{T,E},\n                            B::AbstractVector{P}) where {T, E, P<:AbstractPropagator{T}}\n\nCalculate the equal-time Greens function G(00) = G(betabeta) = I + B(beta0)^-1 using a numerically stable procedure. Also re-calculate the barB_n matrices and the LDR matrix factorizations representing either B(tau0) or B(betatau) stored in fgc.F. This routine is useful for implementing global updates where every propagator matrix B_l has been modified, and the equal-time Green's function needs to be re-calculated from scratch. This method also returns log(vert det G vert) and textrmsign(det G) Note that this routine requires fgc.l == 1 or fgc.l == fgc.Lτ.\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.propagate_equaltime_greens!","page":"API","title":"JDQMCFramework.propagate_equaltime_greens!","text":"propagate_equaltime_greens!(G::AbstractMatrix{T}, fgc::FermionGreensCalculator{T,E},\n                            B::AbstractVector{P}) where {T, E, P<:AbstractPropagator{T}}\n\nPropagate the equal-time Green's function matrix G from the previous imaginary time slice to the current imaginary time slice fgc.l. If iterating over imaginary time in the forward direction (fgc.forward = true) the relationship\n\nG(tau+Deltatautau+Deltatau) = B_l+1 cdot G(tautau) cdot B_l+1^-1\n\nis used, and if iterating over imaginary time in the reverse direction (fgc.forward = false) the relationship\n\nG(tau-Deltatautau-Deltatau)= B_l^-1 cdot G(tautau) cdot B_l\n\nis used instead, where the B_l propagator is given by B[l].\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.stabilize_equaltime_greens!","page":"API","title":"JDQMCFramework.stabilize_equaltime_greens!","text":"stabilize_equaltime_greens!(G::AbstractMatrix{T}, logdetG::E, sgndetG::T,\n                            fgc::FermionGreensCalculator{T,E}, B::AbstractVector{P};\n                            update_B̄::Bool=true)::Tuple{E,T,E,E} where {T, E, P<:AbstractPropagator{T,E}}\n\nStabilize the equal-time Green's function as iterating through imaginary time tau = Deltatau cdot l For a given imaginary time slice fgc.l, this routine should be called after all changes to the B_l propagator have been made. When iterating through imaginary time in the forwards direction (fgc.forward = true), this function re-computes\n\nG(tautau) = I + B(tau0)B(betatau)^-1\n\nwhen at imaginary time slice fgc.l every fgc.nₛ imaginary time slice. When iterating through imaginary time in the reverse direction (fgc.forward = false), this function instead re-computes\n\nG(tau-Deltatautau-Deltatau) = I + B(tau-Deltatau0)B(betatau-Deltatau)^-1\n\nfor fgc.l.\n\nThis method returns four values. The first two values returned are log(vert det G(tautau) vert) and textrmsign(det G(tautau)). The latter two are the maximum error in a Green's function corrected by numerical stabilization vert delta G vert, and the error in the phase of the determinant corrected by numerical stabilization deltatheta relative to naive propagation of the Green's function matrix in imaginary time occuring instead. If no stabilization was performed, than vert delta G vert = 0 and delta theta = 0\n\nThis method also computes the required barB_n matrices, and the LDR matrix factorizations representing B(tau 0) or B(beta tau-Deltatau) when iterating through imaginary time tau = Deltatau cdot l in the forward and reverse directions respectively. If update_B̄ = true, then the barB_n matrices are re-calculated as needed, but if update_B̄ = false, then they are left unchanged.\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.calculate_unequaltime_greens!","page":"API","title":"JDQMCFramework.calculate_unequaltime_greens!","text":"calculate_unequaltime_greens!(Gτ0::AbstractArray{T,3},\n                              fgc::FermionGreensCalculator{T,E},\n                              B::AbstractVector{P}) where {T, E, P<:AbstractPropagator{T}}\n\nCalculate the unequal-time Green's functions G(tau0) for all tau in  0 Deltatau 2Deltatau dots beta-Deltatau beta  The G(tau0) unequal-time Green's function is written to Gτ0[:,:,l+1], where tau = Deltatau cdot l for l in 0 L_τ Therefore,\n\nsize(Gτ0,1) == size(Gτ0,2) == fgc.N\n\nand\n\nsize(Gτ0, 3) == == fgc.Lτ+1\n\nreturn true.\n\n\n\n\n\ncalculate_unequaltime_greens!(Gτ0::AbstractArray{T,3}, Gττ::AbstractArray{T,3},\n                              fgc::FermionGreensCalculator{T,E},\n                              B::AbstractVector{P}) where {T, E, P<:AbstractPropagator{T}}\n\nCalculate the unequal-time Green's functions G(tau0) and the equal-time Green's function G(tautau) for all tau in  0 Deltatau 2Deltatau dots beta-Deltatau beta  The G(tau0) unequal-time Green's function is written to Gτ0[:,:,l+1], and the G(tautau) equal-time Green's function is written to Gττ[:,:,l+1], where tau = Deltatau cdot l for l in 0 L_τ Therefore,\n\nsize(Gτ0,1) == size(Gτ0,2) == size(Gττ,1) == size(Gττ,2) == fgc.N\n\nand\n\nsize(Gτ0, 3) == size(Gττ, 3) == fgc.Lτ+1\n\nreturn true. Note that G(00) = G(betabeta), which means that\n\nGττ[1, 1] ≈ Gττ[fgc.Lτ+1, fgc.Lτ+1]\n\nis true.\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.local_update_det_ratio","page":"API","title":"JDQMCFramework.local_update_det_ratio","text":"local_update_det_ratio(G::AbstractMatrix{T}, B::AbstractPropagator{T,E},\n                       V′::T, i::Int, Δτ::E)::Tuple{T,T} where {T,E}\n\nCalculate the determinant ratio R_li associated with a local update to the equal-time Green's function G(tautau) Also returns Delta_li which is defined below.\n\nArguments\n\nG::AbstractMatrix{T}: Equal-time Green's function matrix G(tautau)\nB::AbstractPropagator{T,E}: Represents the propagator matrix B_l where tau = Deltatau cdot l\nV′::T: The new value for the V^prime_lii matrix element in the diagonal on-site energy matrix V_l\ni::Int: Diagonal matrix element index in V_l being updated.\nΔτ::E: Discretization in imaginary time Deltatau\n\nAlgorithm\n\nThe propagator matrix B_l above is given by\n\nB_l = Lambda_l cdot Gamma_l(Deltatau)\n\nwhere, assuming the we are working in the orbital basis, Gamma_l(Deltatau) = e^-Deltatau K_l represents the exponentiated hopping matrix K_l, and Lambda_l = e^-Deltatau V_l represents the exponentiated diagonal on-site energy matrix V_l\n\nGiven a proposed update to the (ii) matrix element of the diagonal on-site energy matrix V_l, (V_lii rightarrow V^prime_lii) the corresponding determinant ratio associated with this proposed udpate is given by\n\nR_li = fracdet G(tautau)det G^prime(tautau) = 1+Delta_ii(taui)left(1-G_ii(tautau)right)\n\nwhere\n\nDelta_li = fracLambda^prime_liiLambda_lii - 1 = e^-Deltatau (V^prime_lii - V_lii) - 1\n\nThis routine returns the scalar quantities R_li and Delta_li\n\nNote that if the propagator matrix is instead represented using the symmetric form\n\nB_l = Gamma_l(Deltatau2) cdot Lambda_l cdot Gamma^dagger_l(Deltatau2)\n\nthen the matrix G needs to instead represent the transformed equal-time Green's function matrix\n\ntildeG(tautau) = Gamma_l^-1(Deltatau2) cdot G(tautau) cdot Gamma_l(Deltatau2)\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.local_update_greens!","page":"API","title":"JDQMCFramework.local_update_greens!","text":"local_update_greens!(G′::AbstractMatrix{T}, G::AbstractMatrix{T}, logdetG::E, sgndetG::T,\n                     R::T, Δ::T, i::Int)::Tuple{E,T} where {T, E<:AbstractFloat}\n\nUpdate the equal-time Green's function matrix resulting from a local update.\n\nArguments\n\nG′::AbstractMatrix{T}: Updated equal-time Green's function matrix G^prime(tautau), which is modified in-place.\nG::AbstractMatrix{T}: Initial equal-time Green's function matrix G(tautau)\nlogdetG::E: The log of the absolute value of the initial Green's function matrix, log( vert det G(tautau) vert )\nsgndetG::T: The sign/phase of the determinant of the initial Green's function matrix, textrmsign( det G(tautau) )\nR::T: The determinant ratio R_li = fracdet G(tautau)det G^prime(tautau)\nΔ::T: Change in the exponentiated on-site energy matrix, Delta_li = e^-Deltatau (V^prime_l(ii) - V_l(ii)) - 1\ni::Int: Matrix element of diagonal on-site energy matrix V_l that is being updated.\n\nAlgorithm\n\nThe equal-time Green's function matrix is updated using the relationship\n\nG_jk^primeleft(tautauright)=G_jkleft(tautauright)-frac1R_liG_jileft(tautauright)Delta_lileft(delta_ik-G_ikleft(tautauright)right)\n\nThis method also returns log( vert det G^prime(tautau) vert ) and textrmsign( det G^prime(tautau) )\n\nAn important note is that if the propagator matrices are represented in a symmetric form, then G′ and G need to correspond to the transformed eqaul-time Green's function matrices tildeG^prime(tautau) and tildeG(tautau) Refer to the local_update_det_ratio docstring for more information.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utility-Functions","page":"API","title":"Utility Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"eval_length_imaginary_axis\nexp!\nbuild_hopping_matrix!","category":"page"},{"location":"api/","page":"API","title":"API","text":"eval_length_imaginary_axis\nexp!\nbuild_hopping_matrix!","category":"page"},{"location":"api/#JDQMCFramework.eval_length_imaginary_axis","page":"API","title":"JDQMCFramework.eval_length_imaginary_axis","text":"eval_length_imaginary_axis(β::T, Δτ::T)::Int where {T<:AbstractFloat}\n\nGiven an inverse temperature β and discretization in imaginary time Δτ, return the length of the imaginary time axis Lτ.\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.exp!","page":"API","title":"JDQMCFramework.exp!","text":"exp!(expαH::AbstractMatrix{T}, H::AbstractMatrix{T}, α::E;\n     workspace::HermitianEigenWs{T,Matrix{T},R} = HermitianEigenWs(H),\n     tol::R = 1e-6) where {T<:Number, E<:Number, R<:AbstractFloat}\n\nGiven a Hermitian matrix H, calculate the matrix exponentials e^alpha H Note that H is left modified by this method. The workspace field is of type HermitianEigenWs, which is exported from the FastLapackInterface.jl package, is used to avoid dynamic memory allocations.\n\n\n\n\n\nexp!(exppαH::AbstractMatrix{T}, expmαH::AbstractMatrix{T}, H::AbstractMatrix{T}, α::E;\n     workspace::HermitianEigenWs{T,Matrix{T},R} = HermitianEigenWs(H),\n     tol::R = 1e-6) where {T<:Number, E<:Number, R<:AbstractFloat}\n\nGiven a Hermitian matrix H, calculate the matrix exponentials e^+alpha H and e^-alpha H, which are written to exppαH and expmαH respectively. Note that H is left modified by this method. The workspace field is of type HermitianEigenWs, which is exported from the FastLapackInterface.jl package, is used to avoid dynamic memory allocations.\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.build_hopping_matrix!","page":"API","title":"JDQMCFramework.build_hopping_matrix!","text":"build_hopping_matrix!(K::AbstractMatrix{T}, neighbor_table::Matrix{Int}, t::AbstractVector{T}) where {T<:Continuous}\n\nConstruct a hopping matrix K using neighbor_table along with the corresponding hopping amplitudes t. Each column of neighbor_table stores a pair of neighboring orbitals in the lattice, such that size(neighbor_table,1) = 2.\n\n\n\n\n\n","category":"function"},{"location":"api/#Developer-API","page":"API","title":"Developer API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JDQMCFramework.Continuous\nJDQMCFramework.update_factorizations!\nJDQMCFramework.update_B̄!\nJDQMCFramework.calculate_B̄!\nJDQMCFramework.stabilization_interval","category":"page"},{"location":"api/","page":"API","title":"API","text":"JDQMCFramework.Continuous\nJDQMCFramework.update_factorizations!\nJDQMCFramework.update_B̄!\nJDQMCFramework.calculate_B̄!\nJDQMCFramework.stabilization_interval","category":"page"},{"location":"api/#JDQMCFramework.Continuous","page":"API","title":"JDQMCFramework.Continuous","text":"Continuous = Union{AbstractFloat,Complex{<:AbstractFloat}}\n\nAn abstract type to represent continuous real and complex numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/#JDQMCFramework.update_factorizations!","page":"API","title":"JDQMCFramework.update_factorizations!","text":"update_factorizations!(fgc::FermionGreensCalculator{T,E}, B::AbstractVector{P}) where {T, E, P<:AbstractPropagator{T,E}}\n\nIf current imaginary time slice fgc.l corresponds to the boundary of a stabilization interval, calculate a LDR factorization to represent B(0 tau) or B(tau-Deltatau beta) if iterating over imaginary time in the forward (fgc.forward = true) or reverse (fgc.forward = false) directions respectively. This method should be called after all changes to the current time slice propagator matrix B_l have been made This method will also recompute barB_n as needed.\n\n\n\n\n\nupdate_factorizations!(fgc::FermionGreensCalculator{T,E}) where {T, E}\n\nIf current imaginary time slice fgc.l corresponds to the boundary of a stabilization interval, calculate a LDR factorization to represent B(tau 0) or B(beta tau-Deltatau) if iterating over imaginary time in the forward (fgc.forward = true) or reverse (fgc.forward = false) directions respectively. This method should be called after all changes to the current time slice propagator matrix B_l have been made, and any required updates to a barB_n matrix have been performed using the JDQMCFramework.update_B̄! routine.\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.update_B̄!","page":"API","title":"JDQMCFramework.update_B̄!","text":"update_B̄!(fgc::FermionGreensCalculator{T,E}, B::AbstractVector{P}) where {T,E,P<:AbstractPropagator{T,E}}\n\nRecalculate barB_n if the current timeslice fgc.l corresponds to the boundary of a stabilization interval, accounting for whether imaginary time is being iterated over in the forward (fgc.forward = true) or reverse (fgc.forward = false) direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.calculate_B̄!","page":"API","title":"JDQMCFramework.calculate_B̄!","text":"calculate_B̄!(fgc::FermionGreensCalculator{T,E}, B::AbstractVector{P}, n::Int) where {T,E,P<:AbstractPropagator{T,E}}\n\nGiven B, a vector of all the propagator matrices B_l, calculate the matrix product\n\nbarB_sigman=prod_l=(n-1)cdot n_s+1^min(ncdot n_sL_tau)B_sigmal\n\nwith the result getting written to fgc.B̄[:,:,n].\n\n\n\n\n\n","category":"function"},{"location":"api/#JDQMCFramework.stabilization_interval","page":"API","title":"JDQMCFramework.stabilization_interval","text":"stabilization_interval(fgc::FermionGreensCalculator)::Tuple{Int,Int}\n\nGiven the current imaginary time slice fgc.l, return the corresponding stabilization interval n = ceil(Int, fgc.l/fgc.nₛ), and the relative location within that stabilization interval l′ = mod1(fgc.l, fgc.nₛ), such that l′∈[1,nₛ]. \n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = JDQMCFramework","category":"page"},{"location":"#JDQMCFramework.jl","page":"Home","title":"JDQMCFramework.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for JDQMCFramework. This is a utility package that exports a suite of types and routines to simplify the process of writing a DQMC code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Matrix stabilization routines are supplied by the StableLinearAlgebra.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The checkerboard decomposition functionality supported here is provided by the Checkerboard.jl package.","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this code was supported by the U.S. Department of Energy, Office of Science, Basic Energy Sciences, under Award Number DE-SC0022311.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install JDQMCFramework.jl run following in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add JDQMCFramework","category":"page"},{"location":"#Formalism-and-Definitions","page":"Home","title":"Formalism and Definitions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section describes the formalism and definitions adopted by the JDQMCFramework package. The following discussion assumes an existing familiarity with the determinant quantum Monte Carlo (DQMC) algorithm, a method for simulating systems of itinerant fermions on a lattice at finite temperature in the grand canonical ensemble. The DQMC formalism starts by representing the partition funciton as a path integral","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\nZ=  textrmTre^-betahatH=textrmTrleftprod_l=1^L_taue^-DeltatauhatHright\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"in imaginary time tau=lcdotDeltatau, at inverse temperature beta=L_taucdotDeltatau. Next, the Suzuki-Trotter approximation is applied, and Hubbard-Stratonivich transformations are used as needed to render the Hamiltonian quadratic in fermion creation and annihilation operators. Lastly, the fermionic degrees of freedom are integrated out.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The resulting approximate expression for the partition function allows for the definition of Monte Carlo weights of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"W(mathbfx)=e^-S_Bprod_sigmadet M_sigma","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mathbfx signifies all the relevant degrees of freedom that need to be sampled. While not written explicitly, the bosonic action S_B and each fermion determinant matrix M_sigma depend on mathbfx. In the absence of a mean field pairing term or some similarly exotic interaction, the index sigma typically corresponds to the fermion spin species. In the case of electrons this means sigma=uparrowdownarrow.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each fermion determinant matrix is of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\nM_sigma(tau)=  I+B_sigma(tau0)B_sigma(betatau)\n=  I+B_sigmalB_sigmal-1dots B_sigma1B_sigmaL_taudots B_sigmal+2B_sigmal+1\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"B_sigma(tautau)=B_sigmalB_sigmal-1dots B_sigmal+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"such that det M_sigma(tau)=det M_sigma(tau) for any pair (ll)in1L_tau.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each propagator matrix B_sigmal=B_sigma(tautau-Deltatau) may be represented in either the symmetric form","category":"page"},{"location":"","page":"Home","title":"Home","text":"B_sigmal=e^-tfracDeltatau2K_l e^-Deltatau V_l e^-tfracDeltatau2K_l","category":"page"},{"location":"","page":"Home","title":"Home","text":"or the asymmetric form","category":"page"},{"location":"","page":"Home","title":"Home","text":"B_sigmal = e^-Deltatau V_l e^-Deltatau K_l","category":"page"},{"location":"","page":"Home","title":"Home","text":"where V_l is a diagonal matrix corresponding to the on-site energy for each site in the lattice, and K_l is the strictly off-diagonal hopping matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The single-particle fermion Green's function is given by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"G_sigmaij(tautau)=langlehatmathcalThatc_sigmai(tau)hatc_sigmaj^dagger(tau)rangle=begincases\nlanglehatc_sigmai(tau)hatc_sigmaj^dagger(tau)rangle  taugetau\n-langlehatc_sigmaj^dagger(tau)hatc_sigmai(tau)rangle  tautau\nendcases","category":"page"},{"location":"","page":"Home","title":"Home","text":"where hatc_sigmai^dagger(hatc_sigmai) is the fermion creation (annihilation) operator for a fermion with spin sigma on site i on the lattice, and hatmathcalT is the time-ordering operator. The equal-time Green's function is related to the fermion determinant matrix by","category":"page"},{"location":"","page":"Home","title":"Home","text":"G_sigmaij(tautau)=M_sigmaij^-1(tau)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where again tau=lcdotDeltatau. The equal-time Green's function matrix can be advanced to the next imaginary time slice using the relationship","category":"page"},{"location":"","page":"Home","title":"Home","text":"G_sigma(tau+Deltatautau+Deltatau)=B_sigmal+1G_sigma(tautau)B_sigmal+1^-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"and","category":"page"},{"location":"","page":"Home","title":"Home","text":"G_sigma(tau-Deltatautau-Deltatau)=B_sigmal^-1G_sigma(tautau)B_sigmal","category":"page"},{"location":"","page":"Home","title":"Home","text":"The unequal-time Green's function is accessible using the relation","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\nG_sigma(tau0)=  B_sigma(tau0)G_sigma(00)\n=  B_sigma^-1(tau0)+B_sigma(betatau)^-1\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"which also implies","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\nG_sigma(tau0)=  B_sigma^-1(tautau)G_sigma(tau0)\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"for tauin0beta-Deltatau and tautaubeta. By applying the anti-periodic boundary conditions of the single-particle Green's function in imaginary time it immediately follows that","category":"page"},{"location":"","page":"Home","title":"Home","text":"G_sigma(beta0)=I-G_sigma(00)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"G_sigma(00)=I+B_sigma(beta0)^-1=I+B_sigmaL_taudots B_sigma1^-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"subject to the boundary condition G_sigma(00)=G_sigma(betabeta).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The DQMC method also requires periodic re-calculation of the fermion Green's function matrix as G_sigma(tautau) is propagated to later or ealier imaginary times to maintain numerical stability. Therefore, we introduce a parameter n_s which describes the frequency with which numerical stabilization needs to occur. The number of \"stabilization intervals\" in imaginary time is then given by N_s=leftlceil L_taun_sright rceil, and we introduce the notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"barB_sigman=prod_l=(n-1)cdot n_s+1^min(ncdot n_sN_s)B_sigmal","category":"page"},{"location":"","page":"Home","title":"Home","text":"where nin1N_s, to represent the product of propagator matrices over a single stabilization interval. Using this definition we may express G_sigma(00) as","category":"page"},{"location":"","page":"Home","title":"Home","text":"G_sigma(00) = (I + B_sigmaL_tau B_sigmaL_tau-1 dots B_sigma 2 B_sigma1)^-1\n                = (I + barB_sigmaN_s barB_sigmaN_s-1 dots barB_sigma 2 barB_sigma1)^-1","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this section we introduce some of the basics of using this package by setting up the framework for a DQMC simulations in the case of a simple non-interacting square lattice tight binding model, assuming two electron spin species, spin up and spin down. While this is a \"tivial\" example, it is instructive.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra\nusing LatticeUtilities\nusing JDQMCFramework","category":"page"},{"location":"","page":"Home","title":"Home","text":"First let us define the relevant model parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# hopping amplitude\nt = 1.0\n\n# chemical potential\nμ = 0.0\n\n# lattice size\nL = 4\n\n# inverse temperature\nβ = 3.7\n\n# discretization in imaginary time\nΔτ = 0.1\n\n# frequency of numerical stabilization\nnₛ = 10\nnothing; # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next we calculate the length of the imaginary time axis L_tau using the eval_length_imaginary_axis method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lτ = eval_length_imaginary_axis(β, Δτ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using functionality imported from the LatticeUtilities.jl package, we construct the neighbor table for a square lattice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# define unit cell\nunit_cell = UnitCell(lattice_vecs = [[1.,0.],[0.,1.]], basis_vecs = [[0.,0.]])\n\n# define size of lattice\nlattice = Lattice(L = [L,L], periodic = [true,true])\n\n# define bonds/hoppings in x and y directions\nbond_x = Bond(orbitals = (1,1), displacement = [1,0])\nbond_y = Bond(orbitals = (1,1), displacement = [0,1])\n\n# construct neighbor table\nneighbor_table = build_neighbor_table([bond_x, bond_y], unit_cell, lattice)\n\n# calculate number of sites in lattice\nN = get_num_sites(unit_cell, lattice)\n\n# calculate number of bonds in lattice\nNbonds = size(neighbor_table, 2)\n\n(N, Nbonds)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next we construct the strictly off-diagonal hopping matrix K and a vector to represent the diagonal on-site energy matrix V","category":"page"},{"location":"","page":"Home","title":"Home","text":"# build hopping matrix\nK = zeros(typeof(t), N, N)\nbuild_hopping_matrix!(K, neighbor_table, fill(t, Nbonds))\n\n# build vector representing diagonal on-site energy matrix\nV = fill(-μ, N)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we define a the propagator B_sigmal for each spin species sigma and imaginary time slice tau = Deltatau cdot l Of course, in the non-interacting limit considered here all the propagators matrices are identical. This will no longer be the case if interactions are introduced, in which case each B_sigmal matrix will in general be unique.","category":"page"},{"location":"","page":"Home","title":"Home","text":"expmΔτV = exp.(-Δτ*V)\nexpmΔτK = exp(-Δτ*K)\nexppΔτK = exp(+Δτ*K)\n\n# null vector spin up propagators to fill\nBup = AsymExactPropagator{eltype(expmΔτK),eltype(expmΔτV)}[]\n\n# null vecotr of spin down propagators to fill\nBdn = AsymExactPropagator{eltype(expmΔτK),eltype(expmΔτV)}[]\n\n# construct propagator for each spin species and append to appropriate vector\nfor l in 1:Lτ\n    B_l = AsymExactPropagator(expmΔτV, expmΔτK, exppΔτK)\n    push!(Bup, B_l)\n    push!(Bdn, B_l)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the above we chose to represent the propagator matrices using the AsymExactPropagator type, which assumes the B_l = e^-Deltatau K_l e^-Deltatau V_l definition, where the K_l hopping matrix is exactly exponentiated. This package includes the other possible definitions AsymChkbrdPropagator, SymExactPropagator and SymChkbrdPropagator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next we instantiate two instances of the FermionGreensCalculator type, one for each of the two electron spin species, spin up and spin down.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fgc_up = fermion_greens_calculator(Bup, N, β, Δτ, nₛ)\nfgc_dn = fermion_greens_calculator(Bdn, N, β, Δτ, nₛ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we initialize the spin up and spin down equal time Green's function matrices G_uparrow(00) and G_downarrow(00)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gup = zeros(N,N)\nlogdetGup, sgndetGup = calculate_equaltime_greens!(Gup, fgc_up)\n\nGdn = zeros(N,N)\nlogdetGdn, sgndetGdn = calculate_equaltime_greens!(Gdn, fgc_dn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we will demonstrate how to synchronously iterate over the imaginary time slices for both the spin up and spin down sectors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Iterate over imaginary time τ=Δτ⋅l.\nfor l in fgc_up\n\n    # Propagate equal-time Green's function matrix to current imaginary time G(τ±Δτ,τ±Δτ) ==> G(τ,τ)\n    # depending on whether iterating over imaginary time in the forward or reverse direction\n    propagate_equaltime_greens!(Gup, fgc_up, Bup)\n    propagate_equaltime_greens!(Gdn, fgc_dn, Bdn)\n\n    # LOCAL UPDATES OR EVALUATION OF DERIVATIVE OF FERMIONIC ACTION FOR THE CURRENT\n    # IMAGINARY TIME SLICE WOULD GO HERE\n\n    # Periodically re-calculate the Green's function matrix for numerical stability.\n    # Comment: if not performing updates, but just evaluating the derivative of the action, then\n    # set update_B̄=false to avoid wasting cpu time re-computing B̄ₙ matrices.\n    logdetGup, sgndetGup, δGup, δθup = stabilize_equaltime_greens!(Gup, logdetGup, sgndetGup, fgc_up, Bup, update_B̄=true)\n    logdetGdn, sgndetGdn, δGdn, δθdn = stabilize_equaltime_greens!(Gdn, logdetGdn, sgndetGdn, fgc_dn, Bdn, update_B̄=true)\n\n    # Keep up and down spin Green's functions synchronized as iterating over imaginary time.\n    iterate(fgc_dn, fgc_up.forward)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that if we iterate over imaginary time again, it will iterate in the opposite direction. This is expected behavior. Each time you iterate over imaginary time the direction of iteration reverses. While not immediately obvious, this allows for a reduction in the number of required matrix factorizations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package also exports two routines, local_update_det_ratio and local_update_greens!, that are useful for implementing local updates in a DQMC simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lastly, we will will calculate the unequal-time Green's functions G_sigma(tau0) and the equal-time Green's function G_sigma(tautau) for all imaginary time slices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gτ0_up = zeros(N, N, Lτ+1)\nGττ_up = zeros(N, N, Lτ+1)\ncalculate_unequaltime_greens!(Gτ0_up, Gττ_up, fgc_up, Bup)\n\nGτ0_dn = zeros(N, N, Lτ+1)\nGττ_dn = zeros(N, N, Lτ+1)\ncalculate_unequaltime_greens!(Gτ0_dn, Gττ_dn, fgc_dn, Bdn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Calling the calculate_unequaltime_greens! method also reverses the direction of iteration the next time imaginary time is iterated over.","category":"page"}]
}
