<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · JDQMCFramework.jl</title><meta name="title" content="API · JDQMCFramework.jl"/><meta property="og:title" content="API · JDQMCFramework.jl"/><meta property="twitter:title" content="API · JDQMCFramework.jl"/><meta name="description" content="Documentation for JDQMCFramework.jl."/><meta property="og:description" content="Documentation for JDQMCFramework.jl."/><meta property="twitter:description" content="Documentation for JDQMCFramework.jl."/><meta property="og:url" content="https://SmoQySuite.github.io/JDQMCFramework.jl/api/"/><meta property="twitter:url" content="https://SmoQySuite.github.io/JDQMCFramework.jl/api/"/><link rel="canonical" href="https://SmoQySuite.github.io/JDQMCFramework.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JDQMCFramework.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Propagator-Types"><span>Propagator Types</span></a></li><li><a class="tocitem" href="#FermionGreensCalculator-Type"><span>FermionGreensCalculator Type</span></a></li><li><a class="tocitem" href="#DQMC-Building-Block-Routines"><span>DQMC Building Block Routines</span></a></li><li><a class="tocitem" href="#Overloaded-Functions"><span>Overloaded Functions</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Developer-API"><span>Developer API</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/square_hubbard/">Tutorial 1: Square Lattice Hubbard Model DQMC Simulation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/master/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Propagator-Types"><a class="docs-heading-anchor" href="#Propagator-Types">Propagator Types</a><a id="Propagator-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Propagator-Types" title="Permalink"></a></h2><ul><li><a href="#JDQMCFramework.AbstractPropagator"><code>AbstractPropagator</code></a></li><li><a href="#JDQMCFramework.AbstractExactPropagator"><code>AbstractExactPropagator</code></a></li><li><a href="#JDQMCFramework.AbstractChkbrdPropagator"><code>AbstractChkbrdPropagator</code></a></li><li><a href="#JDQMCFramework.SymExactPropagator"><code>SymExactPropagator</code></a></li><li><a href="#JDQMCFramework.AsymExactPropagator"><code>AsymExactPropagator</code></a></li><li><a href="#JDQMCFramework.SymChkbrdPropagator"><code>SymChkbrdPropagator</code></a></li><li><a href="#JDQMCFramework.AsymChkbrdPropagator"><code>AsymChkbrdPropagator</code></a></li><li><a href="#JDQMCFramework.SymPropagators"><code>SymPropagators</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.AbstractPropagator" href="#JDQMCFramework.AbstractPropagator"><code>JDQMCFramework.AbstractPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractPropagator{T&lt;:Continuous, E&lt;:Continuous} end</code></pre><p>Abstract type to represent imaginary time propagator matrices <span>$B$</span>. All specific propagators types inherit from this abstract type. In the above <code>T</code> is data type of the matrix elements of the exponentiated kintetic energy matrix <span>$e^{-\Delta\tau K_l}$</span> appearing in <span>$B_l$</span>, and <code>E</code> is data type of the matrix elements appearing in the diagonal exponentiated potential energy matrix <span>$e^{-\Delta\tau V_l}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.AbstractExactPropagator" href="#JDQMCFramework.AbstractExactPropagator"><code>JDQMCFramework.AbstractExactPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractExactPropagator{T,E} &lt;: AbstractPropagator{T,E} end</code></pre><p>Abstract type to represent imaginary time propagator matrices <span>$B$</span> defined with an exactly exponentiated hopping matrix <span>$K$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.AbstractChkbrdPropagator" href="#JDQMCFramework.AbstractChkbrdPropagator"><code>JDQMCFramework.AbstractChkbrdPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractChkbrdPropagator{T,E} &lt;: AbstractPropagator{T,E} end</code></pre><p>Abstract type to represent imaginary time propagator matrices <span>$B$</span> defined with the exponentiated hopping matrix <span>$K$</span> represented by the checkerboard approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.SymExactPropagator" href="#JDQMCFramework.SymExactPropagator"><code>JDQMCFramework.SymExactPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymExactPropagator{T, E} &lt;: AbstractExactPropagator{T,E}</code></pre><p>Represents imaginary time propagator matrix as using the symmetric form</p><p class="math-container">\[B_l = e^{-\Delta\tau K_l/2} e^{-\Delta\tau V_l} e^{-\Delta\tau K_l/2},\]</p><p>where <span>$K_l$</span> is the strictly off-diagonal hopping matrix and <span>$V_l$</span> is the diagonal total on-site energy matrix.</p><p><strong>Fields</strong></p><ul><li><code>expmΔτV::Vector{E}</code>: A vector representing the diagonal exponeniated on-site energy matrix <span>$e^{-\Delta\tau V_l}.$</span></li><li><code>expmΔτKo2::Matrix{T}</code>: The exponentiated hopping matrix <span>$e^{-\Delta\tau K_l/2}.$</span></li><li><code>exppΔτKo2::Matrix{T}</code>: Inverse of the exponentiated hopping matrix <span>$e^{+\Delta\tau K_l/2}.$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L28-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.AsymExactPropagator" href="#JDQMCFramework.AsymExactPropagator"><code>JDQMCFramework.AsymExactPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AsymExactPropagator{T, E} &lt;: AbstractExactPropagator{T,E}</code></pre><p>Represents imaginary time propagator matrix as using the symmetric form</p><p class="math-container">\[B_l = e^{-\Delta\tau V_l} e^{-\Delta\tau K_l},\]</p><p>where <span>$K_l$</span> is the strictly off-diagonal hopping matrix and <span>$V_l$</span> is the diagonal total on-site energy matrix.</p><p><strong>Fields</strong></p><ul><li><code>expmΔτV::Vector{E}</code>: A vector representing the diagonal exponeniated on-site energy matrix <span>$e^{-\Delta\tau V_l}.$</span></li><li><code>expmΔτK::Matrix{T}</code>: The exponentiated hopping matrix <span>$e^{-\Delta\tau K_l}.$</span></li><li><code>exppΔτK::Matrix{T}</code>: Inverse of the exponentiated hopping matrix <span>$e^{+\Delta\tau K_l}.$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L57-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.SymChkbrdPropagator" href="#JDQMCFramework.SymChkbrdPropagator"><code>JDQMCFramework.SymChkbrdPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymChkbrdPropagator{T, E} &lt;: AbstractChkbrdPropagator{T,E}</code></pre><p>Represents imaginary time propagator matrix as using the symmetric form</p><p class="math-container">\[B_l = e^{-\Delta\tau K_l/2} e^{-\Delta\tau V_l} [e^{-\Delta\tau K_l/2}]^\dagger,\]</p><p>where <span>$K_l$</span> is the strictly off-diagonal hopping matrix and <span>$V_l$</span> is the diagonal total on-site energy matrix. The exponentiated hopping matrix <span>$e^{-\Delta\tau K/2}$</span> is represented by the checkerboard approximation.</p><p><strong>Fields</strong></p><ul><li><code>expmΔτV::Vector{E}</code>: A vector representing the diagonal exponeniated on-site energy matrix <span>$e^{-\Delta\tau V_l}.$</span></li><li><code>expmΔτKo2::CheckerboardMatrix{T}</code>: The exponentiated hopping matrix <span>$e^{-\Delta\tau K_l/2}$</span> represented by the checkerboard approximation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L86-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.AsymChkbrdPropagator" href="#JDQMCFramework.AsymChkbrdPropagator"><code>JDQMCFramework.AsymChkbrdPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AsymChkbrdPropagator{T, E} &lt;: AbstractChkbrdPropagator{T,E}</code></pre><p>Represents imaginary time propagator matrix as using the symmetric form</p><p class="math-container">\[B_l = e^{-\Delta\tau V_l} e^{-\Delta\tau K_l},\]</p><p>where <span>$K_l$</span> is the strictly off-diagonal hopping matrix and <span>$V_l$</span> is the diagonal total on-site energy matrix. The exponentiated hopping matrix <span>$e^{-\Delta\tau K}$</span> is represented by the checkerboard approximation.</p><p><strong>Fields</strong></p><ul><li><code>expmΔτV::Vector{E}</code>: The vector representing the diagonal exponeniated on-site energy matrix <span>$e^{-\Delta\tau V_l}.$</span></li><li><code>expmΔτK::CheckerboardMatrix{T}</code>: The exponentiated hopping matrix <span>$e^{-\Delta\tau K_l}$</span> represented by the checkerboard approximation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L112-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.SymPropagators" href="#JDQMCFramework.SymPropagators"><code>JDQMCFramework.SymPropagators</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymPropagators</code></pre><p>A union of the all the symmetric propagators types to help test whether a propagator type is symmetric. Assuming <code>typeof{B} &lt;: AbstractPropagator</code> returns <code>true</code>, if <code>typeof(B) &lt;: SymPropagators</code> returns <code>true</code>, then <code>B</code> represents a symmetric propagator, otherwise it represents an asymmetric propagator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L138-L144">source</a></section></article><h2 id="FermionGreensCalculator-Type"><a class="docs-heading-anchor" href="#FermionGreensCalculator-Type">FermionGreensCalculator Type</a><a id="FermionGreensCalculator-Type-1"></a><a class="docs-heading-anchor-permalink" href="#FermionGreensCalculator-Type" title="Permalink"></a></h2><ul><li><a href="#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.FermionGreensCalculator" href="#JDQMCFramework.FermionGreensCalculator"><code>JDQMCFramework.FermionGreensCalculator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FermionGreensCalculator{T&lt;:Continuous, E&lt;:AbstractFloat}</code></pre><p>A type to facilitate calculating the single-particle fermion Green&#39;s function matrix.</p><p><strong>Fields</strong></p><ul><li><code>forward::Bool</code>: If <code>true</code> then iterate over imaginary time slices from <span>$l=1$</span> to <span>$l=L_\tau$</span>, if <code>false</code> then iterate over imaginary time slices from <span>$l=L_\tau$</span> to <span>$l=1$</span>.</li><li><code>l::Int</code>: The current imaginary time slice <span>$\tau = l \cdot \Delta\tau$</span>.</li><li><code>n_stab::Int</code>: Frequency with which numerical stabilization is performed, i.e. every <span>$n_s$</span> imaginary time slices the equal-time Green&#39;s function is recomputed from scratch.</li><li><code>N_stab::Int</code>: Number of numerical stabilization intervals, <span>$N_s = \left\lceil L_\tau / n_s \right\rceil.$</span></li><li><code>N::Int</code>: Orbitals in system.</li><li><code>β::E</code>: The inverse temperature <span>$\beta=1/T,$</span> where <span>$T$</span> is temperature.</li><li><code>Δτ::E</code>: Discretization in imaginary time.</li><li><code>Lτ::Int</code>: Length of imaginary time axis, <span>$L_\tau = \beta / \Delta\tau.$</span></li><li><code>B_bar::Vector{Matrix{T}}</code>: A multidimensional array where the matrix <code>B_bar[:,:,n]</code> represents <span>$\bar{B}_n.$</span></li><li><code>F::Vector{LDR{T,E}}</code>: A vector of <span>$N_s$</span> LDR factorizations to represent the matrices <span>$B(0,\tau)$</span> and <span>$B(\tau,\beta)$</span>.</li><li><code>G′::Matrix{T}</code>: Matrix used for calculating the error corrected by numerical stabilization of the equal time Green&#39;s function.</li><li><code>ldr_ws::LDRWorkspace{T}</code>: Workspace for performing LDR factorization while avoiding dynamic memory allocations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.FermionGreensCalculator-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{AbstractVector{P}, E, E, Int64}} where {T&lt;:Number, E&lt;:AbstractFloat, P&lt;:(AbstractPropagator{T})}" href="#JDQMCFramework.FermionGreensCalculator-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{AbstractVector{P}, E, E, Int64}} where {T&lt;:Number, E&lt;:AbstractFloat, P&lt;:(AbstractPropagator{T})}"><code>JDQMCFramework.FermionGreensCalculator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermionGreensCalculator(B::AbstractVector{P}, β::E, Δτ::E,
                        n_stab::Int) where {T&lt;:Number, E&lt;:AbstractFloat, P&lt;:AbstractPropagator{T}}</code></pre><p>Initialize and return <a href="#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a> struct based on the vector of propagators <code>B</code> passed to the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.FermionGreensCalculator-Union{Tuple{FermionGreensCalculator{T, E}}, Tuple{E}, Tuple{T}} where {T, E}" href="#JDQMCFramework.FermionGreensCalculator-Union{Tuple{FermionGreensCalculator{T, E}}, Tuple{E}, Tuple{T}} where {T, E}"><code>JDQMCFramework.FermionGreensCalculator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermionGreensCalculator(fgc::FermionGreensCalculator{T,E}) where {T,E}</code></pre><p>Return a new <a href="#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a> that is a copy of <code>fgc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L94-L98">source</a></section></article><h2 id="DQMC-Building-Block-Routines"><a class="docs-heading-anchor" href="#DQMC-Building-Block-Routines">DQMC Building Block Routines</a><a id="DQMC-Building-Block-Routines-1"></a><a class="docs-heading-anchor-permalink" href="#DQMC-Building-Block-Routines" title="Permalink"></a></h2><ul><li><a href="#JDQMCFramework.calculate_equaltime_greens!"><code>calculate_equaltime_greens!</code></a></li><li><a href="#JDQMCFramework.propagate_equaltime_greens!"><code>propagate_equaltime_greens!</code></a></li><li><a href="#JDQMCFramework.stabilize_equaltime_greens!"><code>stabilize_equaltime_greens!</code></a></li><li><a href="#JDQMCFramework.initialize_unequaltime_greens!"><code>initialize_unequaltime_greens!</code></a></li><li><a href="#JDQMCFramework.propagate_unequaltime_greens!"><code>propagate_unequaltime_greens!</code></a></li><li><a href="#JDQMCFramework.stabilize_unequaltime_greens!"><code>stabilize_unequaltime_greens!</code></a></li><li><a href="#JDQMCFramework.local_update_det_ratio"><code>local_update_det_ratio</code></a></li><li><a href="#JDQMCFramework.local_update_greens!"><code>local_update_greens!</code></a></li><li><a href="#JDQMCFramework.partially_wrap_greens_forward!"><code>partially_wrap_greens_forward!</code></a></li><li><a href="#JDQMCFramework.partially_wrap_greens_reverse!"><code>partially_wrap_greens_reverse!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.calculate_equaltime_greens!" href="#JDQMCFramework.calculate_equaltime_greens!"><code>JDQMCFramework.calculate_equaltime_greens!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calculate_equaltime_greens!(G::AbstractMatrix{T}, fgc::FermionGreensCalculator{T})::Tuple{T,E} where {T}</code></pre><p>Calculate the equal-time Greens function <span>$G(0,0) = G(\beta,\beta) = [I + B(\beta,0)]^{-1}$</span> using a numerically stable procedure. This method also returns <span>$\log(\vert \det G \vert)$</span> and <span>$\textrm{sign}(\det G).$</span> Note that this routine requires <code>fgc.l == 1</code> or <code>fgc.l == fgc.Lτ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/dqmc_routines.jl#L1-L7">source</a></section><section><div><pre><code class="language-julia hljs">calculate_equaltime_greens!(G::AbstractMatrix{T}, fgc::FermionGreensCalculator{T,E},
                            B::AbstractVector{P}) where {T, E, P&lt;:AbstractPropagator{T}}</code></pre><p>Calculate the equal-time Greens function <span>$G(0,0) = G(\beta,\beta) = [I + B(\beta,0)]^{-1}$</span> using a numerically stable procedure. Also re-calculate the <span>$\bar{B}_n$</span> matrices and the LDR matrix factorizations representing either <span>$B(\tau,0)$</span> or <span>$B(\beta,\tau)$</span> stored in <code>fgc.F</code>. This routine is useful for implementing global updates where every propagator matrix <span>$B_l$</span> has been modified, and the equal-time Green&#39;s function needs to be re-calculated from scratch. This method also returns <span>$\log(\vert \det G \vert)$</span> and <span>$\textrm{sign}(\det G).$</span> Note that this routine requires <code>fgc.l == 1</code> or <code>fgc.l == fgc.Lτ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/dqmc_routines.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.propagate_equaltime_greens!" href="#JDQMCFramework.propagate_equaltime_greens!"><code>JDQMCFramework.propagate_equaltime_greens!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">propagate_equaltime_greens!(G::AbstractMatrix{T}, fgc::FermionGreensCalculator{T,E},
                            B::AbstractVector{P}) where {T, E, P&lt;:AbstractPropagator{T}}</code></pre><p>Propagate the equal-time Green&#39;s function matrix <code>G</code> from the previous imaginary time slice to the current imaginary time slice <code>fgc.l</code>. If iterating over imaginary time in the forward direction (<code>fgc.forward = true</code>) the relationship</p><p class="math-container">\[G(\tau+\Delta\tau,\tau+\Delta\tau) = B_{l+1} \cdot G(\tau,\tau) \cdot B_{l+1}^{-1}\]</p><p>is used, and if iterating over imaginary time in the reverse direction (<code>fgc.forward = false</code>) the relationship</p><p class="math-container">\[G(\tau-\Delta\tau,\tau-\Delta\tau)= B_{l}^{-1} \cdot G(\tau,\tau) \cdot B_{l}\]</p><p>is used instead, where the <span>$B_l$</span> propagator is given by <code>B[l]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/dqmc_routines.jl#L53-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.stabilize_equaltime_greens!" href="#JDQMCFramework.stabilize_equaltime_greens!"><code>JDQMCFramework.stabilize_equaltime_greens!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stabilize_equaltime_greens!(G::AbstractMatrix{T}, logdetG::E, sgndetG::T,
                            fgc::FermionGreensCalculator{T,E}, B::AbstractVector{P};
                            update_B̄::Bool=true)::Tuple{E,T,E,E} where {T, E, P&lt;:AbstractPropagator{T}}</code></pre><p>Stabilize the equal-time Green&#39;s function as iterating through imaginary time <span>$\tau = \Delta\tau \cdot l.$</span> For a given imaginary time slice <code>fgc.l</code>, this routine should be called <em>after</em> all changes to the <span>$B_l$</span> propagator have been made. When iterating through imaginary time in the forwards direction (<code>fgc.forward = true</code>), this function re-computes</p><p class="math-container">\[G(\tau,\tau) = [I + B(\tau,0)B(\beta,\tau)]^{-1}\]</p><p>when at imaginary time slice <code>fgc.l</code> every <code>fgc.n_stab</code> imaginary time slice. When iterating through imaginary time in the reverse direction (<code>fgc.forward = false</code>), this function instead re-computes</p><p class="math-container">\[G(\tau-\Delta\tau,\tau-\Delta\tau) = [I + B(\tau-\Delta\tau,0)B(\beta,\tau-\Delta\tau)]^{-1}\]</p><p>for <code>fgc.l</code>.</p><p>This method returns four values. The first two values returned are <span>$\log(\vert \det G(\tau,\tau) \vert)$</span> and <span>$\textrm{sign}(\det G(\tau,\tau))$</span>. The latter two are the maximum error in a Green&#39;s function corrected by numerical stabilization <span>$\vert \delta G \vert$</span>, and the error in the phase of the determinant corrected by numerical stabilization <span>$\delta\theta,$</span> relative to naive propagation of the Green&#39;s function matrix in imaginary time occuring instead. If no stabilization was performed, than <span>$\vert \delta G \vert = 0$</span> and <span>$\delta \theta = 0.$</span></p><p>This method also computes the LDR matrix factorizations representing <span>$B(\tau, 0)$</span> or <span>$B(\beta, \tau-\Delta\tau)$</span> when iterating through imaginary time <span>$\tau = \Delta\tau \cdot l$</span> in the forward and reverse directions respectively. If <code>update_B̄ = true</code>, then the <span>$\bar{B}_n$</span> matrices are re-calculated as needed, but if <code>update_B̄ = false,</code> then they are left unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/dqmc_routines.jl#L101-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.initialize_unequaltime_greens!" href="#JDQMCFramework.initialize_unequaltime_greens!"><code>JDQMCFramework.initialize_unequaltime_greens!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialize_unequaltime_greens!(Gτ0::AbstractMatrix{T}, G0τ::AbstractMatrix{T}, Gττ::AbstractMatrix{T},
                               G00::AbstractMatrix{T}) where {T&lt;:Number}</code></pre><p>Initialize the Green&#39;s function matrices <span>$G(\tau,0),$</span> <span>$G(0,\tau),$</span> and <span>$G(\tau,\tau)$</span> for <span>$\tau = 0$</span> based on the matrix <span>$G(0,0).$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/dqmc_routines.jl#L228-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.propagate_unequaltime_greens!" href="#JDQMCFramework.propagate_unequaltime_greens!"><code>JDQMCFramework.propagate_unequaltime_greens!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">propagate_unequaltime_greens!(Gτ0::AbstractMatrix{T}, G0τ::AbstractMatrix{T}, Gττ::AbstractMatrix{T},
                              fgc::FermionGreensCalculator{T,E}, B::AbstractVector{P}) where {T, E, P&lt;:AbstractPropagator{T}}</code></pre><p>Propagate the Green&#39;s function matrices <span>$G(\tau,0)$</span>, <span>$G(0,\tau)$</span> and <span>$G(\tau,\tau)$</span> from the previous imaginary time slice to the current imaginary time slice <code>fgc.l</code>. If iterating over imaginary time in the forward direction (<code>fgc.forward = true</code>) the relationships</p><p class="math-container">\[\begin{align}
G(\tau,0)    = &amp; B_{l} \cdot G(\tau-\Delta\tau, 0) \\
G(0,\tau)    = &amp; G(0, \tau-\Delta\tau) \cdot B^{-1}_{l} \\
G(\tau,\tau) = &amp; B_{l} \cdot G(\tau-\Delta\tau, \tau-\Delta\tau) \cdot B_{l}^{-1}
\end{align}\]</p><p>are used, and if iterating over imaginary time in the reverse direction (<code>fgc.forward = false</code>) the relationships</p><p class="math-container">\[\begin{align}
G(\tau,0)    = &amp; B_{l+1}^{-1} \cdot G(\tau+\Delta\tau, 0) \\
G(0,\tau)    = &amp; G(0, \tau + \Delta\tau) \cdot B_{l+1} \\
G(\tau,\tau) = &amp; B_{l+1}^{-1} \cdot G(\tau+\Delta\tau, \tau+\Delta\tau) \cdot B_{l+1}
\end{align}\]</p><p>are used instead, where the <span>$B_l$</span> propagator is given by <code>B[l]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/dqmc_routines.jl#L252-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.stabilize_unequaltime_greens!" href="#JDQMCFramework.stabilize_unequaltime_greens!"><code>JDQMCFramework.stabilize_unequaltime_greens!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stabilize_unequaltime_greens!(Gτ0::AbstractMatrix{T}, G0τ::AbstractMatrix{T},
                              Gττ::AbstractMatrix{T}, logdetG::E, sgndetG::T,
                              fgc::FermionGreensCalculator{T,E}, B::AbstractVector{P};
                              update_B̄::Bool=true)::Tuple{E,T,E,E} where {T, E, P&lt;:AbstractPropagator{T}}</code></pre><p>Stabilize the Green&#39;s function matrice <span>$G(\tau,0)$</span>, <span>$G(0,\tau)$</span> and <span>$G(\tau,\tau)$</span> as iterating through imaginary time <span>$\tau = \Delta\tau \cdot l.$</span> For a given imaginary time slice <code>fgc.l</code>, this routine should be called <em>after</em> all changes to the <span>$B_l$</span> propagator have been made. When iterating through imaginary time in the forwards direction (<code>fgc.forward = true</code>), this function re-computes</p><p class="math-container">\[\begin{align}
G(\tau,0)    = &amp; [B^{-1}(\tau,0) + B(\beta,\tau)]^{-1} \\
G(0, \tau)   = &amp; [B^{-1}(\beta,\tau) + B(\tau,0)]^{-1} \\
G(\tau,\tau) = &amp; [I + B(\tau,0)B(\beta,\tau)]^{-1}
\end{align}\]</p><p>when at imaginary time slice <code>fgc.l</code> every <code>fgc.n_stab</code> imaginary time slice. When iterating through imaginary time in the reverse direction (<code>fgc.forward = false</code>), this function instead re-computes</p><p class="math-container">\[\begin{align*}
G(\tau-\Delta\tau,0)               = &amp; [B^{-1}(\tau-\Delta\tau,0) + B(\beta,\tau-\Delta\tau)]^{-1} \\
G(0,\tau-\Delta\tau)               = &amp; [B^{-1}(\beta,\tau-\Delta\tau) + B(\tau-\Delta\tau,0)]^{-1} \\
G(\tau-\Delta\tau,\tau-\Delta\tau) = &amp; [I + B(\tau-\Delta\tau,0)B(\beta,\tau-\Delta\tau)]^{-1}
\begin{align*}\]</p><p>for <code>fgc.l</code>.</p><p>This method returns four values. The first two values returned are <span>$\log(\vert \det G(\tau,\tau) \vert)$</span> and <span>$\textrm{sign}(\det G(\tau,\tau))$</span>. The latter two are the maximum error in a Green&#39;s function corrected by numerical stabilization <span>$\vert \delta G \vert$</span>, and the error in the phase of the determinant corrected by numerical stabilization <span>$\delta\theta,$</span> relative to naive propagation of the Green&#39;s function matrix in imaginary time occuring instead. If no stabilization was performed, than <span>$\vert \delta G \vert = 0$</span> and <span>$\delta \theta = 0.$</span></p><p>This method also computes the LDR matrix factorizations representing <span>$B(\tau, 0)$</span> or <span>$B(\beta, \tau-\Delta\tau)$</span> when iterating through imaginary time <span>$\tau = \Delta\tau \cdot l$</span> in the forward and reverse directions respectively. If <code>update_B̄ = true</code>, then the <span>$\bar{B}_n$</span> matrices are re-calculated as needed, but if <code>update_B̄ = false,</code> then they are left unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/dqmc_routines.jl#L334-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.local_update_det_ratio" href="#JDQMCFramework.local_update_det_ratio"><code>JDQMCFramework.local_update_det_ratio</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_update_det_ratio(G::AbstractMatrix{T}, B::AbstractPropagator{T},
                       V′::T, i::Int, Δτ::E)::Tuple{T,T} where {T,E}</code></pre><p>Calculate the determinant ratio <span>$R_{l,i}$</span> associated with a local update to the equal-time Green&#39;s function <span>$G(\tau,\tau).$</span> Also returns <span>$\Delta_{l,i},$</span> which is defined below.</p><p><strong>Arguments</strong></p><ul><li><code>G::AbstractMatrix{T}</code>: Equal-time Green&#39;s function matrix <span>$G(\tau,\tau).$</span></li><li><code>B::AbstractPropagator{T,E}</code>: Represents the propagator matrix <span>$B_l,$</span> where <span>$\tau = \Delta\tau \cdot l.$</span></li><li><code>V′::T</code>: The new value for the <span>$V^{\prime}_{l,i,i}$</span> matrix element in the diagonal on-site energy matrix <span>$V_l.$</span></li><li><code>i::Int</code>: Diagonal matrix element index in <span>$V_l$</span> being updated.</li><li><code>Δτ::E</code>: Discretization in imaginary time <span>$\Delta\tau.$</span></li></ul><p><strong>Algorithm</strong></p><p>The propagator matrix <span>$B_l$</span> above is given by</p><p class="math-container">\[B_l = \Lambda_l \cdot \Gamma_l(\Delta\tau),\]</p><p>where, assuming the we are working in the orbital basis, <span>$\Gamma_l(\Delta\tau) = e^{-\Delta\tau K_l}$</span> represents the exponentiated hopping matrix <span>$K_l$</span>, and <span>$\Lambda_l = e^{-\Delta\tau V_l}$</span> represents the exponentiated diagonal on-site energy matrix <span>$V_l.$</span></p><p>Given a proposed update to the <span>$(i,i)$</span> matrix element of the diagonal on-site energy matrix <span>$V_l$</span>, (<span>$V_{l,i,i} \rightarrow V^\prime_{l,i,i}),$</span> the corresponding determinant ratio associated with this proposed udpate is given by</p><p class="math-container">\[R_{l,i} = \frac{\det G(\tau,\tau)}{\det G^\prime(\tau,\tau)} = 1+\Delta_{i,i}(\tau,i)\left(1-G_{i,i}(\tau,\tau)\right),\]</p><p>where</p><p class="math-container">\[\Delta_{l,i} = \frac{\Lambda^\prime_{l,i,i}}{\Lambda_{l,i,i}} - 1 = e^{-\Delta\tau (V^\prime_{l,i,i} - V_{l,i,i})} - 1.\]</p><p>This routine returns the scalar quantities <span>$R_{l,i}$</span> and <span>$\Delta_{l,i}.$</span></p><p>Note that if the propagator matrix is instead represented using the symmetric form</p><p class="math-container">\[B_l = \Gamma_l(\Delta\tau/2) \cdot \Lambda_l \cdot \Gamma^\dagger_l(\Delta\tau/2),\]</p><p>then the matrix <code>G</code> needs to instead represent the transformed equal-time Green&#39;s function matrix</p><p class="math-container">\[\tilde{G}(\tau,\tau) = \Gamma_l^{-1}(\Delta\tau/2) \cdot G(\tau,\tau) \cdot \Gamma_l(\Delta\tau/2).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/dqmc_routines.jl#L492-L537">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.local_update_greens!" href="#JDQMCFramework.local_update_greens!"><code>JDQMCFramework.local_update_greens!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_update_greens!(G::AbstractMatrix{T}, logdetG::E, sgndetG::T, B::AbstractPropagator{T}, R::T, Δ::T, i::Int,
                     u::AbstractVector{T}, v::AbstractVector{T})::Tuple{E,T} where {T, E&lt;:AbstractFloat}</code></pre><p>Update the equal-time Green&#39;s function matrix <code>G</code> resulting from a local update in-place.</p><p><strong>Arguments</strong></p><ul><li><code>G::AbstractMatrix{T}</code>: Equal-time Green&#39;s function matrix <span>$G(\tau,\tau)$</span> that will be updated in-place.</li><li><code>logdetG::E</code>: The log of the absolute value of the initial Green&#39;s function matrix, <span>$\log( \vert \det G(\tau,\tau) \vert ).$</span></li><li><code>sgndetG::T</code>: The sign/phase of the determinant of the initial Green&#39;s function matrix, <span>$\textrm{sign}( \det G(\tau,\tau) ).$</span></li><li><code>B::AbstractPropagator{T,E}</code>: Propagator that needs to be updated to reflect accepted local update.</li><li><code>R::T</code>: The determinant ratio <span>$R_{l,i} = \frac{\det G(\tau,\tau)}{\det G^\prime(\tau,\tau)}.$</span></li><li><code>Δ::T</code>: Change in the exponentiated on-site energy matrix, <span>$\Delta_{l,i} = e^{-\Delta\tau (V^\prime_{l,(i,i)} - V_{l,(i,i)})} - 1.$</span></li><li><code>i::Int</code>: Matrix element of diagonal on-site energy matrix <span>$V_l$</span> that is being updated.</li><li><code>u::AbstractVector{T}</code>: Vector of length <code>size(G,1)</code> that is used to avoid dynamic memory allocations.</li><li><code>v::AbstractVector{T}</code>: Vector of length <code>size(G,2)</code> that is used to avoid dynamic memory allocations.</li></ul><p><strong>Algorithm</strong></p><p>The equal-time Green&#39;s function matrix is updated using the relationship</p><p class="math-container">\[G_{j,k}^{\prime}\left(\tau,\tau\right)=G_{j,k}\left(\tau,\tau\right)-\frac{1}{R_{l,i}}G_{j,i}\left(\tau,\tau\right)\Delta_{l,i}\left(\delta_{i,k}-G_{i,k}\left(\tau,\tau\right)\right).\]</p><p>The  <span>$B_l$</span> progpagator <code>B</code> is also udpated. Additionally, this method returns <span>$\log( \vert \det G^\prime(\tau,\tau) \vert )$</span> and <span>$\textrm{sign}( \det G^\prime(\tau,\tau) ).$</span></p><p>An important note is that if the propagator matrices are represented in a symmetric form, then <code>G′</code> and <code>G</code> need to correspond to the transformed eqaul-time Green&#39;s function matrices <span>$\tilde{G}^\prime(\tau,\tau)$</span> and <span>$\tilde{G}(\tau,\tau).$</span> Refer to the <a href="#JDQMCFramework.local_update_det_ratio"><code>local_update_det_ratio</code></a> docstring for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/dqmc_routines.jl#L549-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.partially_wrap_greens_forward!" href="#JDQMCFramework.partially_wrap_greens_forward!"><code>JDQMCFramework.partially_wrap_greens_forward!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partially_wrap_greens_forward!(
    G::Matrix{T},
    B::P,
    M::Matrix{T} = similar(G) # used to avoid dynamic memory allocation
) where {T, E, P&lt;:AbstractPropagator{T,E}}</code></pre><p>If the propagator <code>B</code> is represented in the symmetric form</p><p class="math-container">\[B_l = \Gamma_l(\Delta\tau/2) \cdot \Lambda_l(\Delta\tau) \cdot \Gamma_l^\dagger(\Delta\tau/2)\]</p><p>with <span>$\tau = l \cdot \Delta\tau,$</span> where <span>$\Gamma(\Delta\tau/2) = e^{-\Delta\tau K_l/2}$</span> and <span>$\Lambda(\Delta\tau) = e^{-\Delta\tau V_l}$</span>, then apply the transformation</p><p class="math-container">\[\tilde{G}(\tau,\tau) = \Gamma^{-1}_l(\Delta\tau/2) \cdot G(\tau,\tau) \cdot \Gamma_l(\Delta\tau/2)\]</p><p>to the equal-time Green&#39;s function matrix <code>G</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/partially_wrap_greens.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.partially_wrap_greens_reverse!" href="#JDQMCFramework.partially_wrap_greens_reverse!"><code>JDQMCFramework.partially_wrap_greens_reverse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partially_wrap_greens_reverse!(
    G::Matrix{T},
    B::P,
    M::Matrix{T} = similar(G) # used to avoid dynamic memory allocation
) where {T, E, P&lt;:AbstractPropagator{T,E}}</code></pre><p>If the propagator <code>B</code> is represented in the symmetric form</p><p class="math-container">\[B_l = \Gamma_l(\Delta\tau/2) \cdot \Lambda_l(\Delta\tau) \cdot \Gamma_l^\dagger(\Delta\tau/2)\]</p><p>with <span>$\tau = l \cdot \Delta\tau,$</span> where <span>$\Gamma(\Delta\tau/2) = e^{-\Delta\tau K_l/2}$</span> and <span>$\Lambda(\Delta\tau) = e^{-\Delta\tau V_l}$</span>, then apply the transformation</p><p class="math-container">\[G(\tau,\tau) = \Gamma_l(\Delta\tau/2) \cdot \tilde{G}(\tau,\tau) \cdot \Gamma_l^{-1}(\Delta\tau/2)\]</p><p>to the equal-time Green&#39;s function matrix <code>G</code> in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/partially_wrap_greens.jl#L59-L76">source</a></section></article><h2 id="Overloaded-Functions"><a class="docs-heading-anchor" href="#Overloaded-Functions">Overloaded Functions</a><a id="Overloaded-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Overloaded-Functions" title="Permalink"></a></h2><ul><li><a href="#Base.iterate"><code>iterate</code></a></li><li><a href="#Base.eltype"><code>eltype</code></a></li><li><a href="#Base.resize!"><code>resize!</code></a></li><li><a href="#Base.size"><code>size</code></a></li><li><a href="#Base.copyto!"><code>copyto!</code></a></li><li><a href="#LinearAlgebra.ishermitian"><code>ishermitian</code></a></li><li><a href="#LinearAlgebra.mul!"><code>mul!</code></a></li><li><a href="#LinearAlgebra.lmul!"><code>lmul!</code></a></li><li><a href="#LinearAlgebra.rmul!"><code>rmul!</code></a></li><li><a href="#LinearAlgebra.ldiv!"><code>ldiv!</code></a></li><li><a href="#LinearAlgebra.rdiv!"><code>rdiv!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterate(iter::FermionGreensCalculator)

iterate(iter::FermionGreensCalculator, state)</code></pre><p>Iterate over imaginary time slices, alternating between iterating in the forward direction from <span>$l=1$</span> to <span>$l=L_\tau$</span> and in the reverse direction from <span>$l=L_\tau$</span> to <span>$l=1$</span>. The <code>iter.forward</code> boolean field in the <a href="#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a> type determines whether the imaginary time slices are iterated over in forward or reverse order. The <code>iter.forward</code> field is updated as needed automatically and <em>should not</em> be adjusted manually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L222-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype" href="#Base.eltype"><code>Base.eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eltype(B::AbstractPropagator{T,E}) where {T,E}</code></pre><p>Return the matrix element type of the propagator <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L217-L221">source</a></section><section><div><pre><code class="language-julia hljs">eltype(fgc::FermionGreensCalculator{T,E}) where {T,E}</code></pre><p>Return matrix element type <code>T</code> associated with an instance of <a href="#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.resize!" href="#Base.resize!"><code>Base.resize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resize!(fgc::FermionGreensCalculator{T,E}, G::Matrix{T}, logdetG::E, sgndetG::T,
        B::Vector{P}, n_stab::Int) where {T&lt;:Number, E&lt;:AbstractFloat, P&lt;:AbstractPropagator{T}}

resize!(fgc::FermionGreensCalculator{T,E}, n_stab::Int) where {T,E}</code></pre><p>Update <code>fgc</code> to reflect a new stabilizaiton frequency <code>n_stab</code>. If <code>G</code>, <code>logdetG</code>, <code>sgndetG</code> and <code>B</code> are also passed then the equal-time Green&#39;s function <code>G</code> is re-calculated and the corresponding updated values for <code>(logdetG, sgndetG)</code> are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L128-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">size(B::AbstractPropagator)

size(B::AbstractPropagator, dim)</code></pre><p>Return the size of a propagator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L148-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copyto!" href="#Base.copyto!"><code>Base.copyto!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copyto!(B′::SymExactPropagator{T,E}, B::SymExactPropagator{T,E}) where {T,E}

copyto!(B′::AsymExactPropagator{T,E}, B::AsymExactPropagator{T,E}) where {T,E}

copyto!(B′::SymChkbrdPropagator{T,E}, B::SymChkbrdPropagator{T,E}) where {T,E}

copyto!(B′::AsymChkbrdPropagator{T,E}, B::AsymChkbrdPropagator{T,E}) where {T,E}</code></pre><p>Copy the propagator <code>B</code> to <code>B′</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L171-L181">source</a></section><section><div><pre><code class="language-julia hljs">copyto!(fgc_out::FermionGreensCalculator{T,E}, fgc_in::FermionGreensCalculator{T,E}) where {T,E}</code></pre><p>Copy the contents of <code>fgc_in</code> to <code>fgc_out</code>. If <code>fgc_out.n_stab != fgc_in.n_stab</code> is true, then <code>fgc_out</code> will be resized using <a href="#Base.resize!"><code>resize!</code></a> to match <code>fgc_in</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ishermitian" href="#LinearAlgebra.ishermitian"><code>LinearAlgebra.ishermitian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ishermitian(B::AbstractPropagator)</code></pre><p>Return whether a propagator is hermitian or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.mul!" href="#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul!(A::AbstractMatrix{T}, B::SymExactPropagator{T}, C::AbstractMatrix{T};
     M::AbstractMatrix{T}=similar(A)) where {T}

mul!(A::AbstractMatrix{T}, B::AsymExactPropagator{T}, C::AbstractMatrix{T};
     M::AbstractMatrix{T}=similar(A)) where {T}

mul!(A::AbstractMatrix{T}, B::AbstractChkbrdPropagator{T}, C::AbstractMatrix{T};
     M=nothing) where {T}</code></pre><p>Calculate the product <span>$A := B \cdot C$</span>, where <span>$B$</span> is a propagator matrix represented by an instance of a type inheriting from <a href="#JDQMCFramework.AbstractPropagator"><code>AbstractPropagator</code></a>. If <code>B</code> is asymmetric and <code>B.adjointed = true</code>, then <span>$A = B^\dagger \cdot C$</span> is evaluated instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L228-L241">source</a></section><section><div><pre><code class="language-julia hljs">mul!(A::AbstractMatrix{T}, C::AbstractMatrix{T}, B::SymExactPropagator{T};
     M::AbstractMatrix{T} = similar(A)) where {T}

mul!(A::AbstractMatrix{T}, C::AbstractMatrix{T}, B::AsymExactPropagator{T};
     M::AbstractMatrix{T} = similar(A)) where {T}

mul!(A::AbstractMatrix{T}, C::AbstractMatrix{T}, B::AbstractChkbrdPropagator{T};
     M=nothing) where {T}</code></pre><p>Calculate the matrix product <span>$A := C \cdot B$</span>, where <span>$B$</span> is a propagator matrix represented by an instance of a type inheriting from <a href="#JDQMCFramework.AbstractPropagator"><code>AbstractPropagator</code></a>. If <code>B</code> is asymmetric and <code>B.adjointed = true</code>, then <span>$A = C \cdot B^\dagger$</span> is evaluated instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L271-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lmul!" href="#LinearAlgebra.lmul!"><code>LinearAlgebra.lmul!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lmul!(B::SymExactPropagator{T}, A::AbstractMatrix{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

lmul!(B::AsymExactPropagator{T}, A::AbstractMatrix{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

lmul!(B::AsymExactPropagator{T}, A::AbstractMatrix{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

lmul!(B::AsymChkbrdPropagator{T}, A::AbstractMatrix{T};
      M = nothing) where {T}</code></pre><p>Calculate the matrix product <span>$A := B \cdot A$</span>, where <span>$B$</span> is a propagator matrix represented by an instance of a type inheriting from <a href="#JDQMCFramework.AbstractPropagator"><code>AbstractPropagator</code></a>. If <code>B</code> is asymmetric and <code>B.adjointed = true</code>, when <span>$A := B^\dagger \cdot A$</span> is evaluated instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L314-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.rmul!" href="#LinearAlgebra.rmul!"><code>LinearAlgebra.rmul!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rmul!(A::AbstractMatrix{T}, B::SymExactPropagator{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

rmul!(A::AbstractMatrix{T}, B::AsymExactPropagator{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

rmul!(A::AbstractMatrix{T}, B::SymChkbrdPropagator{T};
      M = nothing) where {T}

rmul!(A::AbstractMatrix{T}, B::AsymChkbrdPropagator{T};
      M = nothing) where {T}</code></pre><p>Calculate the matrix product <span>$A := A \cdot B$</span>, where <span>$B$</span> is a propagator matrix represented by an instance of a type inheriting from <a href="#JDQMCFramework.AbstractPropagator"><code>AbstractPropagator</code></a>. If <code>B</code> is asymmetric and <code>B.adjointed = true</code>, then <span>$A := A \cdot B^\dagger$</span> is evaluated instead. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L371-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ldiv!" href="#LinearAlgebra.ldiv!"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ldiv!(A::AbstractMatrix{T}, B::AbstractExactPropagator{T}, C::AbstractMatrix{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

ldiv!(A::AbstractMatrix{T}, B::AbstractChkbrdPropagator{T}, C::AbstractMatrix{T};
      M = nothing) where {T}</code></pre><p>Calculate the matrix product <span>$A := B^{-1} \cdot C$</span>, where <span>$B$</span> is a propagator matrix represented by an instance of a type inheriting from <a href="#JDQMCFramework.AbstractPropagator"><code>AbstractPropagator</code></a>. If <code>B</code> is asymmetric and <code>B.adjointed = true</code>, then <span>$A = [B^\dagger]^{-1} \cdot C$</span> is evaluated instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L428-L438">source</a></section><section><div><pre><code class="language-julia hljs">ldiv!(B::SymExactPropagator{T}, A::AbstractMatrix{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

ldiv!(B::AsymExactPropagator{T}, A::AbstractMatrix{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

ldiv!(B::SymChkbrdPropagator{T}, A::AbstractMatrix{T};
      M = nothing) where {T}

ldiv!(B::AsymChkbrdPropagator{T}, A::AbstractMatrix{T};
      M = nothing) where {T}</code></pre><p>Calculate the matrix product <span>$A := B^{-1} \cdot A$</span>, where <span>$B$</span> is a propagator matrix represented by an instance of a type inheriting from <a href="#JDQMCFramework.AbstractPropagator"><code>AbstractPropagator</code></a>. If <code>B</code> is asymmetric and <code>B.adjointed = true</code>, then <span>$A := [B^\dagger]^{-1} \cdot A$</span> is evaluated instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L458-L474">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.rdiv!" href="#LinearAlgebra.rdiv!"><code>LinearAlgebra.rdiv!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rldiv!(A::AbstractMatrix{T}, C::AbstractMatrix{T}, B::AbstractExactPropagator{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

rdiv!(A::AbstractMatrix{T}, C::AbstractMatrix{T}, B::AbstractChkbrdPropagator{T};
      M = nothing) where {T}</code></pre><p>Calculate the matrix product <span>$A := C \cdot B^{-1}$</span>, where <span>$B$</span> is a propagator matrix represented by an instance of a type inheriting from <a href="#JDQMCFramework.AbstractPropagator"><code>AbstractPropagator</code></a>. If <code>B</code> is asymmetric and <code>B</code> is asymmetric and <code>B.adjointed = true</code>, then <span>$A = C \cdot [B^\dagger]^{-1}$</span> is evaluated instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L515-L525">source</a></section><section><div><pre><code class="language-julia hljs">rdiv!(A::AbstractMatrix{T}, B::SymExactPropagator{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

rdiv!(A::AbstractMatrix{T}, B::AsymExactPropagator{T};
      M::AbstractMatrix{T} = similar(A)) where {T}

rdiv!(A::AbstractMatrix{T}, B::SymChkbrdPropagator{T};
      M = nothing) where {T}

rdiv!(A::AbstractMatrix{T}, B::AsymChkbrdPropagator{T};
      M = nothing) where {T}</code></pre><p>Calculate the matrix product <span>$A := A \cdot B^{-1}$</span>, where <span>$B$</span> is a propagator matrix represented by an instance of a type inheriting from <a href="#JDQMCFramework.AbstractPropagator"><code>AbstractPropagator</code></a>. If <code>B</code> is asymmetric and <code>B.adjointed = true</code>, then <span>$A := A \cdot [B^\dagger]^{-1}$</span> is evaluated instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/Propagators.jl#L545-L561">source</a></section></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><ul><li><a href="#JDQMCFramework.eval_length_imaginary_axis"><code>eval_length_imaginary_axis</code></a></li><li><a href="#JDQMCFramework.exp!"><code>exp!</code></a></li><li><a href="#JDQMCFramework.build_hopping_matrix!"><code>build_hopping_matrix!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.eval_length_imaginary_axis" href="#JDQMCFramework.eval_length_imaginary_axis"><code>JDQMCFramework.eval_length_imaginary_axis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_length_imaginary_axis(β::T, Δτ::T)::Int where {T&lt;:AbstractFloat}</code></pre><p>Given an inverse temperature <code>β</code> and discretization in imaginary time <code>Δτ</code>, return the length of the imaginary time axis <code>Lτ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/utility_functions.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.exp!" href="#JDQMCFramework.exp!"><code>JDQMCFramework.exp!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exp!(expαH::AbstractMatrix{T}, H::AbstractMatrix{T}, α::E;
     workspace::HermitianEigenWs{T,Matrix{T},R} = HermitianEigenWs(H),
     tol::R = 1e-6) where {T&lt;:Number, E&lt;:Number, R&lt;:AbstractFloat}</code></pre><p>Given a Hermitian matrix <code>H</code>, calculate the matrix exponentials <span>$e^{\alpha H}.$</span> Note that <code>H</code> is left modified by this method. The <code>workspace</code> field is of type <a href="https://dynarejulia.github.io/FastLapackInterface.jl/dev/workspaces/#FastLapackInterface.HermitianEigenWs"><code>HermitianEigenWs</code></a>, which is exported from the <a href="https://github.com/DynareJulia/FastLapackInterface.jl"><code>FastLapackInterface.jl</code></a> package, is used to avoid dynamic memory allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/utility_functions.jl#L14-L24">source</a></section><section><div><pre><code class="language-julia hljs">exp!(exppαH::AbstractMatrix{T}, expmαH::AbstractMatrix{T}, H::AbstractMatrix{T}, α::E;
     workspace::HermitianEigenWs{T,Matrix{T},R} = HermitianEigenWs(H),
     tol::R = 1e-6) where {T&lt;:Number, E&lt;:Number, R&lt;:AbstractFloat}</code></pre><p>Given a Hermitian matrix <code>H</code>, calculate the matrix exponentials <span>$e^{+\alpha H}$</span> and <span>$e^{-\alpha H}$</span>, which are written to <code>exppαH</code> and <code>expmαH</code> respectively. Note that <code>H</code> is left modified by this method. The <code>workspace</code> field is of type <a href="https://dynarejulia.github.io/FastLapackInterface.jl/dev/workspaces/#FastLapackInterface.HermitianEigenWs"><code>HermitianEigenWs</code></a>, which is exported from the <a href="https://github.com/DynareJulia/FastLapackInterface.jl"><code>FastLapackInterface.jl</code></a> package, is used to avoid dynamic memory allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/utility_functions.jl#L43-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.build_hopping_matrix!" href="#JDQMCFramework.build_hopping_matrix!"><code>JDQMCFramework.build_hopping_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_hopping_matrix!(K::AbstractMatrix{T}, neighbor_table::Matrix{Int}, t::AbstractVector{T}) where {T&lt;:Continuous}</code></pre><p>Construct a hopping matrix <code>K</code> using <code>neighbor_table</code> along with the corresponding hopping amplitudes <code>t</code>. Each column of <code>neighbor_table</code> stores a pair of neighboring orbitals in the lattice, such that <code>size(neighbor_table,1) = 2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/utility_functions.jl#L77-L82">source</a></section></article><h2 id="Developer-API"><a class="docs-heading-anchor" href="#Developer-API">Developer API</a><a id="Developer-API-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-API" title="Permalink"></a></h2><ul><li><a href="#JDQMCFramework.Continuous"><code>JDQMCFramework.Continuous</code></a></li><li><a href="#JDQMCFramework.update_factorizations!"><code>JDQMCFramework.update_factorizations!</code></a></li><li><a href="#JDQMCFramework.update_B̄!"><code>JDQMCFramework.update_B̄!</code></a></li><li><a href="#JDQMCFramework.calculate_B̄!"><code>JDQMCFramework.calculate_B̄!</code></a></li><li><a href="#JDQMCFramework.stabilization_interval"><code>JDQMCFramework.stabilization_interval</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.Continuous" href="#JDQMCFramework.Continuous"><code>JDQMCFramework.Continuous</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Continuous = Union{AbstractFloat,Complex{&lt;:AbstractFloat}}</code></pre><p>An abstract type to represent continuous real and complex numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/JDQMCFramework.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.update_factorizations!" href="#JDQMCFramework.update_factorizations!"><code>JDQMCFramework.update_factorizations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_factorizations!(fgc::FermionGreensCalculator{T,E}, B::AbstractVector{P}) where {T, E, P&lt;:AbstractPropagator{T}}</code></pre><p>If current imaginary time slice <code>fgc.l</code> corresponds to the boundary of a stabilization interval, calculate a LDR factorization to represent <span>$B(0, \tau)$</span> or <span>$B(\tau-\Delta\tau, \beta)$</span> if iterating over imaginary time in the forward (<code>fgc.forward = true</code>) or reverse (<code>fgc.forward = false</code>) directions respectively. This method should be called <em>after</em> all changes to the current time slice propagator matrix <span>$B_l$</span> have been made This method will also recompute <span>$\bar{B}_n$</span> as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L278-L288">source</a></section><section><div><pre><code class="language-julia hljs">update_factorizations!(fgc::FermionGreensCalculator{T,E}) where {T, E}</code></pre><p>If current imaginary time slice <code>fgc.l</code> corresponds to the boundary of a stabilization interval, calculate a LDR factorization to represent <span>$B(\tau, 0)$</span> or <span>$B(\beta, \tau-\Delta\tau)$</span> if iterating over imaginary time in the forward (<code>fgc.forward = true</code>) or reverse (<code>fgc.forward = false</code>) directions respectively. This method should be called <em>after</em> all changes to the current time slice propagator matrix <span>$B_l$</span> have been made, and any required updates to a <span>$\bar{B}_n$</span> matrix have been performed using the <a href="#JDQMCFramework.update_B̄!"><code>JDQMCFramework.update_B̄!</code></a> routine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L300-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.update_B̄!" href="#JDQMCFramework.update_B̄!"><code>JDQMCFramework.update_B̄!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_B̄!(fgc::FermionGreensCalculator{T,E}, B::AbstractVector{P}) where {T,E,P&lt;:AbstractPropagator{T}}</code></pre><p>Recalculate <span>$\bar{B}_n$</span> if the current timeslice <code>fgc.l</code> corresponds to the boundary of a stabilization interval, accounting for whether imaginary time is being iterated over in the forward (<code>fgc.forward = true</code>) or reverse (<code>fgc.forward = false</code>) direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L359-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.calculate_B̄!" href="#JDQMCFramework.calculate_B̄!"><code>JDQMCFramework.calculate_B̄!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calculate_B̄!(fgc::FermionGreensCalculator{T,E}, B::AbstractVector{P}, n::Int) where {T,E,P&lt;:AbstractPropagator{T}}</code></pre><p>Given <code>B</code>, a vector of all the propagator matrices <span>$B_l$</span>, calculate the matrix product</p><p class="math-container">\[\bar{B}_{\sigma,n}=\prod_{l=(n-1)\cdot n_{s}+1}^{\min(n\cdot n_{s},L_{\tau})}B_{\sigma,l},\]</p><p>with the result getting written to <code>fgc.B_bar[n]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L393-L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JDQMCFramework.stabilization_interval" href="#JDQMCFramework.stabilization_interval"><code>JDQMCFramework.stabilization_interval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stabilization_interval(fgc::FermionGreensCalculator)::Tuple{Int,Int}</code></pre><p>Given the current imaginary time slice <code>fgc.l</code>, return the corresponding stabilization interval <code>n = ceil(Int, fgc.l/fgc.n_stab)</code>, and the relative location within that stabilization interval <code>l′ = mod1(fgc.l, fgc.n_stab)</code>, such that <code>l′∈[1,n_stab]</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/JDQMCFramework.jl/blob/8a5760da81b4e2693c0a6a04ec2c5d85f3f86359/src/FermionGreensCalculator.jl#L418-L424">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorials/square_hubbard/">Tutorial 1: Square Lattice Hubbard Model DQMC Simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Saturday 30 December 2023 19:39">Saturday 30 December 2023</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
